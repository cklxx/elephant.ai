# 前端通信与 UI 组件改进计划
> Last updated: 2025-11-18


## 现状诊断

### 通信架构
- `useSSE` 同时承担了连接管理、事件解析、事件列表累积以及针对特定事件类型的副作用（如环境快照、沙盒进度），导致职责过于集中且难以扩展新的事件通道。【F:web/hooks/useSSE.ts†L70-L205】
- 为了兼容旧组件，`useAgentStreamIntegration` 在 `useSSE` 之上又同步一份事件到 Zustand store，形成“双写”路径，既增加了重构复杂度，也让事件来源难以追踪。【F:web/hooks/useAgentStreamIntegration.ts†L1-L54】

### 事件状态聚合
- 事件聚合逻辑位于 store 内部，使用 LRU 缓存后在 `addEvent` 中重新扫描全部事件；随着事件量增长，频繁的全量衍生计算会拖慢前端渲染。【F:web/hooks/useAgentStreamStore.ts†L72-L146】
- 聚合出的研究步骤状态为 `pending/in_progress/completed`，但 UI 组件 `ResearchTimeline` 期待的是 `pending/active/complete/error`，状态语义不一致导致进度展示与真实数据之间存在转换缺口，需要在中间层再做映射，增加了维护成本。【F:web/lib/eventAggregation.ts†L278-L345】【F:web/components/agent/ResearchTimeline.tsx†L18-L205】

### 工具输出组件
- `ToolCallCard` 在单个组件内同时处理参数预览、流式输出、结果/错误、阶段时间线等逻辑，并依赖运行时条件判断来渲染不同段落，难以针对不同工具提供差异化视图或重用局部模块。【F:web/components/agent/ToolCallCard.tsx†L1-L145】
- 面向工具输出的面板、标题、复制按钮等子结构都内嵌在卡片内部，缺乏可以跨工具复用的基础组件，重复定义了多组样式与交互。【F:web/components/agent/ToolCallCard.tsx†L201-L333】

### 研究步骤展示
- 研究计划编辑组件负责 DnD、审批、拒绝等交互，但缺乏与实时进度的解耦视图，导致待办列表既承担计划管理又承担执行反馈，易产生信息噪音。【F:web/components/agent/ResearchPlanCard.tsx†L1-L200】
- 时间线组件在列表项内部混合了折叠控制、状态徽章、工具/Token 细节等信息，缺乏“当前待办”“已完成”“异常”三个清晰板块，用户难以快速定位当前步骤和下一步行动。【F:web/components/agent/ResearchTimeline.tsx†L101-L205】

## 改进任务总览

| 模块 | 目标 | 完成状态 |
| --- | --- | --- |
| 通信链路 | 拆分 `SSEClient`/`EventPipeline`，提供事件注册表与事件总线 | ✅ 首版落地，SSE 客户端/事件管道/总线已集成 |
| 事件聚合 | 引入增量聚合与统一状态枚举 | ✅ 首版落地，Zustand 归一化状态与统一状态枚举已上线 |
| 工具组件 | 构建 `ToolCallLayout` 及工具渲染注册表 | ✅ 首版落地，工具卡片骨架与浏览器/终端/文件渲染器已启用 |
| 研究进度面板 | 拆分计划/执行/历史布局，统一进度摘要组件 | ✅ 会话计划卡片已解耦，统一进度摘要与跳转联动上线 |

> **进度说明**：本文档已完成架构诊断与设计规划（✅），后续迭代将按阶段逐项落地。表格中的状态会随实现推进更新为“进行中”“已完成”。

## 改进目标
1. 构建解耦的前端事件通信链路，降低扩展新事件类型的成本。
2. 建立面向工具运行过程的组件库，以组件组合方式支持不同工具的专属呈现。
3. 提升研究步骤进度展示的可读性，让“计划-执行-反馈”信息通路清晰可见。

## 分阶段设计方案

### 阶段一：通信层模块化
1. 抽象 `SSEClient`（连接管理）与 `EventPipeline`（事件解析、验证、分发）两个层次，`useSSE` 仅负责将管道输出写入 React 状态。
2. 引入事件注册表（`eventRegistry`），将硬编码的事件列表与处理器解耦；每种事件类型注册解析器与副作用处理器，支持按需扩展。
3. 在 store 内侧只存储归一化后的事件（例如以 call_id/iteration 作为 key），避免组件重新消费原始事件数组。
4. 建立全局 `AgentEventBus`（可基于 `RxJS` 或轻量自定义订阅器），允许诊断面板、日志窗口等订阅不同的事件流切片。

### 阶段二：事件聚合与状态对齐
1. 将聚合逻辑拆分为纯函数，接入增量计算（例如对新事件执行 `reduce`），避免每次全量扫描。
2. 定义统一的步骤状态枚举（`planned | active | done | failed`），并在 UI 与 store 之间共享类型，消除进度展示的语义差异。
3. 为研究计划与实时步骤建立双向映射：计划用于“待办列表”，实时步骤用于“进度时间线”，通过共享的 ID 对齐两者。

### 阶段三：工具组件体系
1. 设计 `ToolCallLayout` 基础骨架（头部、状态栏、内容区、操作区），将 `ToolCallCard` 拆分为可组合的子组件（参数面板、流式输出区、结果摘要等）。
2. 构建工具渲染注册表（`toolRenderers`），针对常见工具（浏览器、Shell、文件操作、分析模型等）提供专属组件；默认回退到通用模板。
3. 定义工具级别的“数据适配器”，在渲染前将事件聚合结果转换为组件所需的 props，减少组件内部对原始事件的判断分支。
4. 补充 UI 库示例与 Storybook 场景，方便设计/前端协作评审。

### 阶段四：研究步骤展示优化
1. 在页面布局中引入“计划板（待办）”“执行中”“历史记录”三个栏位，分别挂载计划列表、当前活动步骤、已完成/异常步骤。
2. 将 `ResearchPlanCard` 的审批、拖拽逻辑下沉到专属管理视图；在会话流中仅展示只读的计划概览与状态。
3. 使用统一的进度摘要组件（展示完成率、耗时、工具数等指标），与时间线共享数据来源。
4. 支持按状态过滤与跳转（点击待办即可在时间线中聚焦对应事件）。

## 里程碑复盘

- ✅ 梳理现有通信架构、工具展示、进度展示问题并输出改进目标（本文档已完成）。
- ✅ **里程碑 1：通信层模块化验证**
  - ✅ 完成 `SSEClient` 与 `EventPipeline` 的接口草案。
  - ✅ 在 Storybook 中模拟事件流，验证新 Hook 的最小实现。
  - ✅ 在实验分支替换 `useSSE`，确保基础会话流程正常。
- ✅ **里程碑 2：事件聚合与状态统一**
  - ✅ 将聚合逻辑迁移为纯函数并覆盖单元测试。
  - ✅ 更新 Zustand store 以存储归一化结构，消除“双写”。
  - ✅ 对接统一的步骤状态枚举并同步 UI 层适配。
- ✅ **里程碑 3：工具组件库建设**
  - ✅ 拆分 `ToolCallCard`，提炼 `ToolCallLayout` 及通用子组件。
  - ✅ 为浏览器、Shell、文件工具建立专属渲染器与 Storybook 展示。
  - ✅ 建立工具数据适配器，消除组件内部条件渲染分支。
- ✅ **里程碑 4：研究步骤展示升级**
  - ✅ 设计并实现计划/执行/历史三栏布局。
  - ✅ 下沉 `ResearchPlanCard` 的管理逻辑，仅保留会话视图展示。
  - ✅ 提供统一进度摘要组件并打通跳转联动。

## 交付与验证
- **设计稿**：通信架构图、组件交互稿、研究步骤布局线框。
- **技术方案文档**：事件注册表接口定义、工具渲染器 API、状态枚举迁移指南。
- **渐进式落地**：优先改造通信链路与聚合，再逐步替换 UI 组件，确保现有页面在每个阶段均可运行。
- **验收标准**：
  - SSE 新增事件类型时不需要修改核心 Hook；
  - 不同工具的输出组件可在 Storybook 中独立演示；
  - 进度面板能够区分计划、执行、完成三类信息且状态同步无延迟。
