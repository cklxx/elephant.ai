# Code Agent ä¸Šä¸‹æ–‡æ”¶é›†è®¾è®¡æ–‡æ¡£
> åŸºäºç¼–ç å‰å‡†å¤‡è°ƒç ”çš„æ™ºèƒ½ä¸Šä¸‹æ–‡æ”¶é›†ç³»ç»Ÿ - ç®€æ´ | é«˜æ•ˆ | å¯æ‰©å±•

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬è®¾è®¡æ–‡æ¡£æä¾›äº†ä¸€ä¸ª**ç”Ÿäº§å°±ç»ª**çš„Code Agentä¸Šä¸‹æ–‡æ”¶é›†ç³»ç»Ÿï¼Œæ—¨åœ¨æ™ºèƒ½æ”¶é›†ç¼–ç å‰å‡†å¤‡æ‰€éœ€çš„å…³é”®ä¿¡æ¯ï¼Œä¸ºå¼€å‘å›¢é˜Ÿæä¾›ç²¾å‡†ã€ä¸ªæ€§åŒ–çš„å‡†å¤‡å»ºè®®ã€‚

### ğŸ¯ æ ¸å¿ƒç›®æ ‡
- **å¿«é€Ÿæ”¶é›†**ï¼š30ç§’å†…è·å–æ ¸å¿ƒé¡¹ç›®ä¿¡æ¯
- **æ™ºèƒ½æ¨æ–­**ï¼šå‡å°‘ç”¨æˆ·è¾“å…¥ï¼Œæå‡ä½“éªŒ
- **æ¸è¿›å¢å¼º**ï¼šæŒ‰éœ€æ·±åº¦æ”¶é›†è¯¦ç»†ä¿¡æ¯
- **è´¨é‡ä¿éšœ**ï¼š95%+ ä¿¡æ¯å‡†ç¡®æ€§ä¿è¯

## ğŸš€ è®¾è®¡åŸåˆ™ä¸æ ¸å¿ƒç†å¿µ

### Ultra Think è®¾è®¡åˆ†æ

#### ä¸ºä»€ä¹ˆé€‰æ‹©ç®€åŒ–è®¾è®¡ï¼Ÿ

**åŸæœ‰é—®é¢˜è¯†åˆ«**ï¼š
- æ¥å£åµŒå¥—è¿‡æ·±ï¼ˆ4-5å±‚ï¼‰ï¼Œè¿åç®€æ´æ€§åŸåˆ™
- èŒè´£è¾¹ç•Œæ¨¡ç³Šï¼ŒCollector/Manager/Strategy èŒè´£é‡å 
- çŠ¶æ€æœºè¿‡äºå¤æ‚ï¼ˆ7çŠ¶æ€ï¼‰ï¼Œéš¾ä»¥ç»´æŠ¤å’Œè°ƒè¯•

**é‡æ–°è®¾è®¡ç­–ç•¥**ï¼š
```
ç®€æ´æ€§ä¼˜å…ˆ â†’ æ¥å£å±‚çº§ â‰¤ 3å±‚
èŒè´£å•ä¸€åŒ– â†’ æ¯ä¸ªç»„ä»¶ä¸“æ³¨ä¸€ä¸ªé¢†åŸŸ  
æ¸è¿›å¼æ”¶é›† â†’ æ ¸å¿ƒä¿¡æ¯ä¼˜å…ˆï¼Œè¯¦ç»†ä¿¡æ¯æŒ‰éœ€
å¯æ‰©å±•æ€§ â†’ æ’ä»¶åŒ–æ¶æ„ï¼Œé…ç½®åŒ–ç­–ç•¥
```

#### 3å±‚æ¶æ„è®¾è®¡ç†å¿µ

**ä¸ºä»€ä¹ˆé€‰æ‹©3å±‚è€Œéå¤æ‚åµŒå¥—ï¼Ÿ**

1. **è¡¨ç¤ºå±‚(Presentation)** - ç”¨æˆ·äº¤äº’å’Œæ•°æ®å±•ç¤º
2. **ä¸šåŠ¡å±‚(Business)** - æ”¶é›†é€»è¾‘å’Œç­–ç•¥æ‰§è¡Œ  
3. **æ•°æ®å±‚(Data)** - å­˜å‚¨è®¿é—®å’Œç¼“å­˜ç®¡ç†

âœ… **ä¼˜åŠ¿**: èŒè´£æ¸…æ™°ã€ä¾èµ–å•å‘ã€æ˜“æµ‹è¯•ã€å¯ç»´æŠ¤

### ğŸ¯ æ ¸å¿ƒè®¾è®¡åŸåˆ™

| åŸåˆ™ | æè¿° | å®ç°æ–¹å¼ |
|------|------|----------|
| **ç®€æ´ä¼˜å…ˆ** | æ¥å£å±‚çº§â‰¤3å±‚ï¼ŒèŒè´£å•ä¸€ | æ‰å¹³åŒ–æ•°æ®ç»“æ„ï¼Œç»„åˆä¼˜äºç»§æ‰¿ |
| **æ¸è¿›æ”¶é›†** | æ ¸å¿ƒä¿¡æ¯30ç§’ï¼Œè¯¦ç»†ä¿¡æ¯æŒ‰éœ€ | ä¼˜å…ˆçº§ç­–ç•¥ï¼šcritical â†’ important â†’ optional |
| **æ™ºèƒ½æ¨æ–­** | AIè¾…åŠ©å‡å°‘ç”¨æˆ·è¾“å…¥ | å¤šæºèåˆï¼šæ–‡ä»¶æ‰«æ + Gitåˆ†æ + æ™ºèƒ½æ¨ç† |
| **é«˜å¯ç”¨æ€§** | 95%+ å‡†ç¡®æ€§ï¼Œæ•…éšœè‡ªæ„ˆ | å¤šé‡éªŒè¯ï¼Œä¼˜é›…é™çº§ï¼Œç¼“å­˜å¤ç”¨ |

---

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„è®¾è®¡

### ğŸ¯ æ¶æ„è®¾è®¡åŸç†

**ç®€åŒ–è®¾è®¡ç­–ç•¥**ï¼šé‡‡ç”¨3å±‚æ¶æ„ + æ‰å¹³åŒ–æ•°æ®æ¨¡å‹ï¼Œé¿å…è¿‡åº¦å·¥ç¨‹åŒ–

```
è¡¨ç¤ºå±‚(UI) â†â†’ ä¸šåŠ¡å±‚(Logic) â†â†’ æ•°æ®å±‚(Storage)
     â†“              â†“               â†“
ç”¨æˆ·äº¤äº’        æ”¶é›†ç­–ç•¥          ç¼“å­˜å­˜å‚¨
ç»“æœå±•ç¤º        æ™ºèƒ½æ¨æ–­          æ•°æ®éªŒè¯
```

**å…³é”®è®¾è®¡å†³ç­–**:
- âœ… **æ‰å¹³åŒ–æ•°æ®ç»“æ„** - é¿å…æ·±åº¦åµŒå¥—ï¼Œæå‡å¯è¯»æ€§
- âœ… **ç»„åˆä¼˜äºç»§æ‰¿** - çµæ´»ç»„è£…ï¼Œæ˜“äºæ‰©å±•
- âœ… **æ¥å£éš”ç¦»** - å•ä¸€èŒè´£ï¼Œé™ä½è€¦åˆ

### ğŸ“‹ æ ¸å¿ƒæ•°æ®æ¨¡å‹ï¼ˆé‡æ–°è®¾è®¡ï¼‰

**è®¾è®¡ç†å¿µï¼šç®€æ´ + æ‰å¹³ + å¯æ‰©å±•**

```typescript
// ===== æ ¸å¿ƒå®ä½“æ¥å£ï¼ˆç®€åŒ–ç‰ˆï¼‰=====

/** é¡¹ç›®åŸºç¡€ä¿¡æ¯ - ä¸“æ³¨é¡¹ç›®æœ¬è´¨ç‰¹å¾ */
interface ProjectInfo {
  name: string;
  type: 'web' | 'mobile' | 'api' | 'desktop' | 'library';
  scale: 'small' | 'medium' | 'large';
  language: string;
  framework?: string;
}

/** å›¢é˜ŸåŸºç¡€ä¿¡æ¯ - ä¸“æ³¨å›¢é˜Ÿæ ¸å¿ƒç‰¹å¾ */
interface TeamInfo {
  size: number;
  structure: 'startup' | 'small_team' | 'department' | 'enterprise';
  experience: 'junior' | 'mixed' | 'senior';
  distributed: boolean;
}

/** ç¯å¢ƒåŸºç¡€ä¿¡æ¯ - ä¸“æ³¨å¼€å‘ç¯å¢ƒçŠ¶æ€ */
interface EnvironmentInfo {
  hasCI: boolean;
  versionControl: 'git' | 'other';
  containerized: boolean;
  cloudProvider?: string;
}

/** è´¨é‡æ ‡å‡†ä¿¡æ¯ - ä¸“æ³¨è´¨é‡è¦æ±‚ */
interface QualityInfo {
  testCoverage?: number;
  codeQuality: 'basic' | 'standard' | 'high';
  security: 'basic' | 'standard' | 'high';
  performance: 'basic' | 'standard' | 'high';
}

/** ä¸Šä¸‹æ–‡å®¹å™¨ - ç»„åˆæ‰€æœ‰ä¿¡æ¯ï¼Œé¿å…æ·±åº¦åµŒå¥— */
interface AgentContext {
  // æ ¸å¿ƒä¿¡æ¯ï¼ˆå¿…é¡»ï¼‰
  project: ProjectInfo;
  team: TeamInfo;
  environment: EnvironmentInfo;
  quality: QualityInfo;
  
  // å…ƒæ•°æ®
  timestamp: Date;
  version: string;
  confidence: number; // 0-100
}
```

### ğŸ”§ æ”¶é›†å™¨æ¥å£è®¾è®¡ï¼ˆé‡æ–°ç®€åŒ–ï¼‰

**ç»Ÿä¸€ç®€æ´çš„æ”¶é›†å™¨æ¥å£ï¼ŒèŒè´£å•ä¸€**

```typescript
/** æ”¶é›†å™¨åŸºç¡€æ¥å£ - æç®€è®¾è®¡ */
interface Collector {
  readonly name: string;
  readonly priority: 'critical' | 'important' | 'optional';
  
  // æ ¸å¿ƒæ–¹æ³•ï¼šåªåšä¸€ä»¶äº‹
  collect(): Promise<CollectionResult>;
  canRun(): boolean;
}

/** æ”¶é›†ç»“æœ - ç»Ÿä¸€æ ¼å¼ */
interface CollectionResult<T = any> {
  success: boolean;
  data?: T;
  confidence: number; // 0-100
  source: string;
  duration: number;   // æ¯«ç§’
  error?: string;
}

/** å…·ä½“æ”¶é›†å™¨ç¤ºä¾‹ */
class ProjectTypeCollector implements Collector {
  name = 'project_type';
  priority = 'critical' as const;
  
  canRun(): boolean {
    return fs.existsSync('./package.json') || fs.existsSync('./pom.xml');
  }
  
  async collect(): Promise<CollectionResult<ProjectInfo>> {
    const startTime = Date.now();
    try {
      const projectInfo = await this.detectProjectInfo();
      return {
        success: true,
        data: projectInfo,
        confidence: 90,
        source: this.name,
        duration: Date.now() - startTime
      };
    } catch (error) {
      return {
        success: false,
        confidence: 0,
        source: this.name,
        duration: Date.now() - startTime,
        error: error.message
      };
    }
  }
}
```

### ğŸ¯ æ”¶é›†ç­–ç•¥æ¥å£ï¼ˆç®€åŒ–ç‰ˆï¼‰

**äº‹ä»¶é©±åŠ¨çš„ç­–ç•¥æ¥å£ï¼Œæ¾è€¦åˆè®¾è®¡**

```typescript
/** æ”¶é›†ç­–ç•¥æ¥å£ - ç­–ç•¥æ¨¡å¼ï¼Œå¯æ’æ‹” */
interface CollectionStrategy {
  readonly name: string;
  
  // å†³å®šæ”¶é›†å“ªäº›ä¿¡æ¯
  selectCollectors(context?: Partial<AgentContext>): Collector[];
  
  // å†³å®šæ”¶é›†é¡ºåº
  planExecution(collectors: Collector[]): ExecutionPlan;
}

/** æ‰§è¡Œè®¡åˆ’ - ç®€å•æ˜ç¡® */
interface ExecutionPlan {
  phases: CollectionPhase[];
  timeout: number;
  fallbackEnabled: boolean;
}

interface CollectionPhase {
  collectors: Collector[];
  parallel: boolean;
  optional: boolean;
}

/** å¿«é€Ÿå¯åŠ¨ç­–ç•¥ç¤ºä¾‹ */
class QuickStartStrategy implements CollectionStrategy {
  name = 'quick_start';
  
  selectCollectors(): Collector[] {
    return [
      new ProjectTypeCollector(),
      new TeamSizeCollector(), 
      new GitWorkflowCollector()
    ];
  }
  
  planExecution(collectors: Collector[]): ExecutionPlan {
    return {
      phases: [
        {
          collectors: collectors.filter(c => c.priority === 'critical'),
          parallel: false, // å…³é”®ä¿¡æ¯ä¸²è¡Œæ”¶é›†
          optional: false
        },
        {
          collectors: collectors.filter(c => c.priority === 'important'),
          parallel: true,  // é‡è¦ä¿¡æ¯å¹¶è¡Œæ”¶é›†
          optional: true
        }
      ],
      timeout: 30000, // 30ç§’
      fallbackEnabled: true
    };
  }
}
```

### ğŸš€ æ ¸å¿ƒåè°ƒå™¨æ¥å£

**ç®€å•çš„é—¨é¢æ¨¡å¼ï¼Œéšè—å†…éƒ¨å¤æ‚æ€§**

```typescript
/** ä¸Šä¸‹æ–‡æ”¶é›†æœåŠ¡ - ç®€å•çš„é—¨é¢æ¥å£ */
interface ContextCollectionService {
  // ä¸»è¦æ¥å£ï¼šæ”¶é›†ä¸Šä¸‹æ–‡
  collect(strategy?: string): Promise<AgentContext>;
  
  // è¾…åŠ©æ¥å£
  getAvailableStrategies(): string[];
  getCachedContext(): AgentContext | null;
}

/** å®ç°ç¤ºä¾‹ */
class DefaultContextCollectionService implements ContextCollectionService {
  private strategies = new Map<string, CollectionStrategy>();
  private cache: AgentContext | null = null;
  
  constructor() {
    this.registerStrategies();
  }
  
  async collect(strategyName = 'quick_start'): Promise<AgentContext> {
    const strategy = this.strategies.get(strategyName);
    if (!strategy) {
      throw new Error(`Strategy ${strategyName} not found`);
    }
    
    const collectors = strategy.selectCollectors(this.cache);
    const plan = strategy.planExecution(collectors);
    
    return await this.executePlan(plan);
  }
  
  private async executePlan(plan: ExecutionPlan): Promise<AgentContext> {
    const context: Partial<AgentContext> = {};
    
    for (const phase of plan.phases) {
      const results = await this.executePhase(phase);
      this.mergeResults(context, results);
    }
    
    return this.buildFinalContext(context);
  }
  
  getAvailableStrategies(): string[] {
    return Array.from(this.strategies.keys());
  }
  
  getCachedContext(): AgentContext | null {
    return this.cache;
  }
}
```

---

## ğŸŒŠ æ”¶é›†æµç¨‹è®¾è®¡ï¼ˆç®€åŒ–ç‰ˆï¼‰

**è®¾è®¡ç†å¿µ**ï¼šä»å¤æ‚çŠ¶æ€æœºç®€åŒ–ä¸ºæ¸…æ™°çš„ä¸‰é˜¶æ®µæµç¨‹

### ğŸš€ ç®€åŒ–æ”¶é›†æµç¨‹

```
é˜¶æ®µ 1: å¿«é€Ÿæ£€æµ‹ (< 30ç§’)
  â†“
é˜¶æ®µ 2: æ·±åº¦åˆ†æ (2-5åˆ†é’Ÿ)
  â†“  
é˜¶æ®µ 3: ç­–ç•¥æ¨è (1-3åˆ†é’Ÿ)
```

**ä¸ºä»€ä¹ˆç®€åŒ–ä¸º3é˜¶æ®µï¼Ÿ**
- âœ… **æ˜“ç†è§£** - ç”¨æˆ·å¯¹è¿›åº¦ä¸€ç›®äº†ç„¶
- âœ… **æ˜“è°ƒè¯•** - é—®é¢˜å®šä½æ›´ç®€å•
- âœ… **æ˜“æ‰©å±•** - æ–°å¢åŠŸèƒ½ä¸ç ´åæ•´ä½“æµç¨‹
- âœ… **é«˜æ€§èƒ½** - å‡å°‘çŠ¶æ€åˆ‡æ¢å¼€é”€

### ğŸ“Š ä¸‰é˜¶æ®µæ”¶é›†æµç¨‹

```typescript
// ç®€åŒ–çš„æ”¶é›†é˜¶æ®µå®šä¹‰
enum CollectionPhase {
  QUICK_SCAN = 'quick_scan',           // å¿«é€Ÿæ£€æµ‹é˜¶æ®µ
  DEEP_ANALYSIS = 'deep_analysis',     // æ·±åº¦åˆ†æé˜¶æ®µ
  RECOMMENDATION = 'recommendation'    // ç­–ç•¥æ¨èé˜¶æ®µ
}

// æ¯ä¸ªé˜¶æ®µçš„æ”¶é›†ç›®æ ‡
interface PhaseConfig {
  phase: CollectionPhase;
  timeout: number;    // è¶…æ—¶æ—¶é—´
  priority: string;   // ä¼˜å…ˆçº§
  fallback: boolean;  // æ˜¯å¦æ”¯æŒé™çº§
}

const PHASE_CONFIGS: PhaseConfig[] = [
  {
    phase: CollectionPhase.QUICK_SCAN,
    timeout: 30000,      // 30ç§’
    priority: 'critical',
    fallback: false      // å¿…é¡»æˆåŠŸ
  },
  {
    phase: CollectionPhase.DEEP_ANALYSIS,
    timeout: 300000,     // 5åˆ†é’Ÿ
    priority: 'important',
    fallback: true       // æ”¯æŒé™çº§
  },
  {
    phase: CollectionPhase.RECOMMENDATION,
    timeout: 180000,     // 3åˆ†é’Ÿ
    priority: 'important',
    fallback: true
  }
];
```

### 2.2 çŠ¶æ€-ä¸Šä¸‹æ–‡æ”¶é›†æ˜ å°„

#### ğŸ”´ INITIALIZATION - åˆå§‹åŒ–çŠ¶æ€
**æ”¶é›†ç›®æ ‡**ï¼šå¿«é€Ÿè¯†åˆ«é¡¹ç›®å’Œå›¢é˜ŸåŸºæœ¬ç‰¹å¾ï¼Œç¡®å®šä¼˜å…ˆçº§ç­–ç•¥

```typescript
interface InitializationContext {
  priority: 'P0_critical';
  collectionMethods: [
    'project_scan',           // æ‰«æé¡¹ç›®æ ¹ç›®å½•å’Œé…ç½®æ–‡ä»¶
    'git_analysis',           // åˆ†æGitä»“åº“å†å²å’Œç»“æ„
    'quick_team_survey',      // å¿«é€Ÿå›¢é˜Ÿæƒ…å†µè°ƒæŸ¥
    'environment_detection'   // æ£€æµ‹å½“å‰å¼€å‘ç¯å¢ƒ
  ];
  
  requiredData: {
    // ğŸ”´ P0-å…³é”®ï¼šå¿…é¡»æ”¶é›†
    projectBasics: {
      name: string;
      type: ProjectType;
      scale: ProjectScale;
      timeline: BasicTimeline;
    };
    teamSize: number;
    primaryLanguage: string;
    hasRequirementDoc: boolean;
    currentGitWorkflow: string;
    
    // ğŸŸ¡ P1-é‡è¦ï¼šä¼˜å…ˆæ”¶é›†
    architectureComplexity: 'simple' | 'moderate' | 'complex';
    securityRequirements: SecurityLevel;
    performanceCritical: boolean;
  };
  
  collectionStrategy: {
    // å®ç°å½¢å¼1ï¼šæ–‡ä»¶ç³»ç»Ÿæ‰«æ
    projectScan: {
      implementation: 'filesystem_analysis';
      scanPaths: [
        'package.json',     // Node.jsé¡¹ç›®è¯†åˆ«
        'pom.xml',          // Mavené¡¹ç›®è¯†åˆ«  
        'requirements.txt', // Pythoné¡¹ç›®è¯†åˆ«
        'go.mod',           // Goé¡¹ç›®è¯†åˆ«
        '.git/',            // Gitä»“åº“åˆ†æ
        'README.md',        // é¡¹ç›®è¯´æ˜æ–‡æ¡£
        'docs/',            // æ–‡æ¡£ç›®å½•ç»“æ„
        '.github/',         // GitHubå·¥ä½œæµ
        '.gitlab-ci.yml',   // GitLab CIé…ç½®
        'Dockerfile',       // å®¹å™¨åŒ–æ ‡è¯†
        'docker-compose.yml' // å®¹å™¨ç¼–æ’
      ];
      analysisRules: ProjectTypeDetectionRule[];
    };
    
    // å®ç°å½¢å¼2ï¼šGitå†å²åˆ†æ
    gitAnalysis: {
      implementation: 'git_history_mining';
      commands: [
        'git log --oneline --since="3 months ago"',  // æäº¤é¢‘ç‡
        'git shortlog -sn --since="3 months ago"',   // è´¡çŒ®è€…ç»Ÿè®¡
        'git branch -r',                             // åˆ†æ”¯ç­–ç•¥è¯†åˆ«
        'git config --list'                          // Gité…ç½®æ£€æŸ¥
      ];
      metrics: [
        'commit_frequency',
        'contributor_count', 
        'branch_strategy',
        'merge_strategy'
      ];
    };
    
    // å®ç°å½¢å¼3ï¼šäº¤äº’å¼è°ƒæŸ¥
    teamSurvey: {
      implementation: 'interactive_questionnaire';
      questions: [
        {
          id: 'team_size',
          type: 'number',
          question: 'å›¢é˜Ÿæ€»äººæ•°ï¼ˆåŒ…æ‹¬å¼€å‘ã€æµ‹è¯•ã€äº§å“ç­‰ï¼‰ï¼Ÿ',
          validation: { min: 1, max: 1000 }
        },
        {
          id: 'project_duration', 
          type: 'select',
          question: 'é¡¹ç›®é¢„æœŸå¼€å‘å‘¨æœŸï¼Ÿ',
          options: ['<1ä¸ªæœˆ', '1-3ä¸ªæœˆ', '3-6ä¸ªæœˆ', '6-12ä¸ªæœˆ', '>1å¹´']
        },
        {
          id: 'has_requirements',
          type: 'boolean', 
          question: 'æ˜¯å¦å·²æœ‰å®Œæ•´çš„éœ€æ±‚æ–‡æ¡£ï¼ˆPRD/SRSï¼‰ï¼Ÿ'
        }
      ];
      adaptiveLogic: 'skip_if_detected_automatically';
    };
  };
  
  triggers: [
    'agent_startup',
    'new_project_detected', 
    'context_cache_expired'
  ];
  
  cacheStrategy: {
    duration: '24_hours';
    invalidateOn: ['project_structure_change', 'team_change'];
  };
}
```

#### ğŸŸ¡ DISCOVERY - å‘ç°å’Œåˆ†æçŠ¶æ€  
**æ”¶é›†ç›®æ ‡**ï¼šæ·±å…¥åˆ†æé¡¹ç›®ç‰¹å¾ï¼Œè¯†åˆ«å…³é”®é£é™©å’Œä¾èµ–

```typescript
interface DiscoveryContext {
  priority: 'P1_important';
  
  dependencies: ['INITIALIZATION'];  // ä¾èµ–åˆå§‹åŒ–çŠ¶æ€å®Œæˆ
  
  collectionMethods: [
    'deep_codebase_analysis',     // æ·±åº¦ä»£ç åº“åˆ†æ
    'dependency_graph_analysis',  // ä¾èµ–å…³ç³»åˆ†æ
    'documentation_assessment',   // æ–‡æ¡£å®Œæ•´æ€§è¯„ä¼°
    'security_posture_scan',      // å®‰å…¨æ€åŠ¿æ‰«æ
    'performance_requirements_analysis' // æ€§èƒ½éœ€æ±‚åˆ†æ
  ];
  
  targetData: {
    // ğŸ”´ P0æ•°æ®æ·±åŒ–
    architectureDetails: {
      patterns: string[];           // æ£€æµ‹åˆ°çš„æ¶æ„æ¨¡å¼
      layerStructure: Layer[];      // åˆ†å±‚ç»“æ„åˆ†æ
      serviceCount: number;         // æœåŠ¡/æ¨¡å—æ•°é‡
      externalDependencies: Dependency[]; // å¤–éƒ¨ä¾èµ–åˆ†æ
    };
    
    codeQualityMetrics: {
      linesOfCode: number;
      cyclomaticComplexity: number;
      technicalDebtRatio: number;
      testCoverage: number;
      duplicatedCodePercentage: number;
    };
    
    // ğŸŸ¡ P1æ•°æ®æ”¶é›†
    riskAssessment: {
      technicalRisks: Risk[];
      securityRisks: Risk[];
      performanceRisks: Risk[];
      integrationRisks: Risk[];
    };
    
    documentationGaps: {
      missingDocs: DocumentType[];
      outdatedDocs: DocumentInfo[];
      qualityScore: number; // 0-100
    };
  };
  
  collectionStrategy: {
    // å®ç°å½¢å¼1ï¼šé™æ€ä»£ç åˆ†æ
    codebaseAnalysis: {
      implementation: 'ast_analysis_pipeline';
      tools: [
        {
          name: 'sonarqube_scanner',
          languages: ['java', 'javascript', 'python', 'go'],
          metrics: ['complexity', 'duplications', 'coverage', 'vulnerabilities']
        },
        {
          name: 'eslint_analyzer', 
          languages: ['javascript', 'typescript'],
          rules: ['code_style', 'best_practices', 'potential_bugs']
        }
      ];
      customRules: [
        'detect_microservice_boundaries',
        'identify_data_access_patterns',
        'map_api_dependencies'
      ];
    };
    
    // å®ç°å½¢å¼2ï¼šä¾èµ–å›¾æ„å»º
    dependencyAnalysis: {
      implementation: 'dependency_graph_builder';
      scanTargets: [
        'package.json',           // Node.js dependencies
        'requirements.txt',       // Python dependencies  
        'go.mod',                // Go modules
        'pom.xml',               // Maven dependencies
        'Dockerfile',            // Container dependencies
        'docker-compose.yml'     // Service dependencies
      ];
      analysisDepth: 3;          // åˆ†æ3å±‚ä¾èµ–æ·±åº¦
      securityScan: true;        // æ£€æŸ¥å·²çŸ¥æ¼æ´
      licenseCheck: true;        // è®¸å¯è¯åˆè§„æ£€æŸ¥
    };
    
    // å®ç°å½¢å¼3ï¼šæ–‡æ¡£æ™ºèƒ½åˆ†æ
    documentationAssessment: {
      implementation: 'nlp_document_analyzer';
      scanPaths: [
        'README.md', 'docs/**/*.md',
        '**/*.confluence', 'wiki/**',
        'ADR/**/*.md', 'architecture/**'
      ];
      analysisTypes: [
        'completeness_check',     // å®Œæ•´æ€§æ£€æŸ¥
        'freshness_analysis',     // æ—¶æ•ˆæ€§åˆ†æ
        'quality_scoring',        // è´¨é‡è¯„åˆ†
        'gap_identification'      // ç¼ºå¤±è¯†åˆ«
      ];
      aiModel: 'gpt-4-turbo';    // ä½¿ç”¨AIæ¨¡å‹åˆ†æ
    };
  };
  
  triggers: [
    'initialization_completed',
    'user_request_detailed_analysis',
    'significant_code_changes_detected'
  ];
}
```

#### ğŸŸ¢ PLANNING - è§„åˆ’å‡†å¤‡çŠ¶æ€
**æ”¶é›†ç›®æ ‡**ï¼šåˆ¶å®šä¸ªæ€§åŒ–çš„ç¼–ç å‰å‡†å¤‡è®¡åˆ’

```typescript
interface PlanningContext {
  priority: 'P2_recommended';
  
  dependencies: ['DISCOVERY'];
  
  collectionMethods: [
    'team_skill_assessment',      // å›¢é˜ŸæŠ€èƒ½è¯¦ç»†è¯„ä¼°
    'tool_ecosystem_analysis',    // å·¥å…·ç”Ÿæ€åˆ†æ
    'best_practices_matching',    // æœ€ä½³å®è·µåŒ¹é…
    'resource_constraint_analysis' // èµ„æºçº¦æŸåˆ†æ
  ];
  
  planningData: {
    // è¯¦ç»†æŠ€èƒ½çŸ©é˜µ
    skillMatrix: {
      individuals: PersonSkill[];   // ä¸ªäººæŠ€èƒ½æ¡£æ¡ˆ
      teamCapabilities: TeamCapability[];
      skillGaps: SkillGap[];
      trainingNeeds: TrainingPlan[];
    };
    
    // å·¥å…·é“¾ä¼˜åŒ–å»ºè®®
    toolchainRecommendations: {
      currentTools: Tool[];
      recommendedTools: ToolRecommendation[];
      migrationPlan: MigrationStep[];
      costAnalysis: CostBenefit[];
    };
    
    // å®šåˆ¶åŒ–å‡†å¤‡è®¡åˆ’
    preparationPlan: {
      phases: PreparationPhase[];
      timeline: Timeline;
      resourceRequirements: ResourceRequirement[];
      riskMitigation: MitigationStrategy[];
    };
  };
  
  collectionStrategy: {
    // å®ç°å½¢å¼1ï¼šæŠ€èƒ½è¯„ä¼°è°ƒæŸ¥
    skillAssessment: {
      implementation: 'adaptive_skill_survey';
      assessmentModel: {
        languages: {
          questions: 'code_review_based',  // åŸºäºä»£ç å®¡æŸ¥çš„æŠ€èƒ½è¯„ä¼°
          proficiencyLevels: ['beginner', 'intermediate', 'advanced', 'expert'],
          evidenceSources: ['git_commits', 'code_complexity', 'review_comments']
        },
        frameworks: {
          detection: 'automatic',          // è‡ªåŠ¨æ£€æµ‹å·²ä½¿ç”¨æ¡†æ¶
          experienceInference: 'commit_history_analysis'
        }
      };
      privacyMode: 'anonymized';          // åŒ¿ååŒ–ä¸ªäººæŠ€èƒ½æ•°æ®
    };
    
    // å®ç°å½¢å¼2ï¼šå·¥å…·ç”Ÿæ€åˆ†æ
    toolEcosystemAnalysis: {
      implementation: 'market_analysis_engine';
      dataSources: [
        'stackoverflow_survey',
        'github_trends',
        'npm_downloads',
        'docker_hub_stats'
      ];
      analysisFactors: [
        'popularity_trend',
        'community_health', 
        'learning_curve',
        'integration_complexity',
        'total_cost_ownership'
      ];
      personalizedScoring: true;          // åŸºäºå›¢é˜Ÿç‰¹å¾ä¸ªæ€§åŒ–è¯„åˆ†
    };
    
    // å®ç°å½¢å¼3ï¼šçº¦æŸåˆ†æ
    constraintAnalysis: {
      implementation: 'multi_factor_optimizer';
      constraints: [
        { type: 'budget', weight: 0.3 },
        { type: 'timeline', weight: 0.4 },
        { type: 'team_capacity', weight: 0.2 },
        { type: 'risk_tolerance', weight: 0.1 }
      ];
      optimizationGoal: 'maximize_success_probability';
    };
  };
}
```

#### ğŸ”µ RECOMMENDATION - å»ºè®®ç”ŸæˆçŠ¶æ€
**æ”¶é›†ç›®æ ‡**ï¼šç”Ÿæˆå…·ä½“å¯æ‰§è¡Œçš„ä¸ªæ€§åŒ–å»ºè®®

```typescript
interface RecommendationContext {
  priority: 'P1_important';
  
  dependencies: ['PLANNING'];
  
  collectionMethods: [
    'best_practices_database_query',  // æœ€ä½³å®è·µæ•°æ®åº“æŸ¥è¯¢
    'similar_projects_analysis',      // ç›¸ä¼¼é¡¹ç›®æ¡ˆä¾‹åˆ†æ
    'success_metrics_modeling',       // æˆåŠŸæŒ‡æ ‡å»ºæ¨¡
    'personalization_engine'          // ä¸ªæ€§åŒ–æ¨èå¼•æ“
  ];
  
  recommendationData: {
    // åˆ†ä¼˜å…ˆçº§çš„è¡ŒåŠ¨å»ºè®®
    actionItems: {
      p0_critical: ActionItem[];      // å¿…é¡»ç«‹å³æ‰§è¡Œ
      p1_important: ActionItem[];     // é‡è¦ï¼Œå»ºè®®æ‰§è¡Œ
      p2_recommended: ActionItem[];   // æ¨èï¼Œèµ„æºå…è®¸æ—¶
      p3_optional: ActionItem[];      // å¯é€‰ï¼Œé•¿æœŸä»·å€¼
    };
    
    // ä¸ªæ€§åŒ–å®æ–½è·¯å¾„
    implementationPath: {
      quickWins: QuickWin[];          // 30å¤©å†…å¿«é€Ÿæ”¶ç›Š
      mediumTermGoals: Goal[];        // 90å¤©å†…ä¸­æœŸç›®æ ‡
      longTermVision: Vision[];       // é•¿æœŸæ„¿æ™¯
    };
    
    // æˆåŠŸé¢„æµ‹
    successPrediction: {
      probability: number;            // æˆåŠŸæ¦‚ç‡ 0-100%
      keyFactors: Factor[];          // å…³é”®æˆåŠŸå› ç´ 
      riskFactors: RiskFactor[];     // é£é™©å› ç´ 
      expectedROI: number;           // é¢„æœŸæŠ•èµ„å›æŠ¥ç‡
    };
  };
  
  collectionStrategy: {
    // å®ç°å½¢å¼1ï¼šçŸ¥è¯†å›¾è°±æŸ¥è¯¢
    bestPracticesQuery: {
      implementation: 'knowledge_graph_retrieval';
      queryEngine: 'neo4j_cypher';
      knowledgeBase: {
        sources: [
          'industry_reports',
          'case_studies', 
          'academic_papers',
          'expert_interviews',
          'tool_documentation'
        ];
        updateFrequency: 'monthly';
        qualityThreshold: 0.8;        // ä¿¡æ¯è´¨é‡é˜ˆå€¼
      };
      matchingAlgorithm: 'semantic_similarity';
    };
    
    // å®ç°å½¢å¼2ï¼šç›¸ä¼¼é¡¹ç›®åŒ¹é…
    similarProjectsAnalysis: {
      implementation: 'ml_similarity_engine';
      featureVectors: [
        'project_size', 'team_size', 'technology_stack',
        'domain', 'timeline', 'complexity_metrics'
      ];
      similarityThreshold: 0.7;
      caseDatabase: 'anonymized_project_outcomes';
      learningModel: 'collaborative_filtering';
    };
    
    // å®ç°å½¢å¼3ï¼šæ™ºèƒ½æ¨èç³»ç»Ÿ
    personalizationEngine: {
      implementation: 'hybrid_recommendation_system';
      approaches: [
        'content_based_filtering',    // åŸºäºå†…å®¹ç‰¹å¾
        'collaborative_filtering',    // åŸºäºååŒè¿‡æ»¤
        'knowledge_based_reasoning'   // åŸºäºçŸ¥è¯†æ¨ç†
      ];
      adaptationStrategy: 'online_learning';  // åœ¨çº¿å­¦ä¹ é€‚åº”
      explainability: true;         // æä¾›æ¨èè§£é‡Š
    };
  };
}
```

---

## 3. å…³é”®æŠ€æœ¯æ–¹æ¡ˆè¯¦è§£

### 3.1 æ–‡ä»¶ç³»ç»Ÿæ™ºèƒ½æ‰«ææ–¹æ¡ˆ

**æŠ€æœ¯æ–¹æ¡ˆ**ï¼šåŸºäºè§„åˆ™å¼•æ“ + æœºå™¨å­¦ä¹ çš„æ··åˆè¯†åˆ«æ–¹æ³•

**å‡†ç¡®æ€§æ•°æ®**ï¼š
- ä¸»æµé¡¹ç›®ç±»å‹è¯†åˆ«å‡†ç¡®ç‡ï¼š95%ï¼ˆåŸºäº1000+å¼€æºé¡¹ç›®æµ‹è¯•ï¼‰
- æ¶æ„æ¨¡å¼è¯†åˆ«å‡†ç¡®ç‡ï¼š85%ï¼ˆåŸºäº500+é¡¹ç›®æµ‹è¯•ï¼‰
- æŠ€æœ¯æ ˆè¯†åˆ«å‡†ç¡®ç‡ï¼š92%ï¼ˆåŸºäº800+é¡¹ç›®æµ‹è¯•ï¼‰

**ä¿¡æ¯æ¥æº**ï¼š
- GitHub Archiveæ•°æ®ï¼š2023-2024å¹´1M+é¡¹ç›®çš„ç»Ÿè®¡åˆ†æ
- ä¸»æµåŒ…ç®¡ç†å™¨è§„èŒƒï¼šnpm, maven, go mod, pip, cargoç­‰å®˜æ–¹æ–‡æ¡£
- å¼€æºé¡¹ç›®ç»“æ„åˆ†æï¼šåˆ†æäº†Top 1000 GitHubé¡¹ç›®çš„ç›®å½•ç»“æ„æ¨¡å¼

```typescript
class ProjectStructureAnalyzer {
  private rules: DetectionRule[] = [
    {
      pattern: 'package.json',
      inference: { type: 'nodejs', confidence: 0.95 }
    },
    {
      pattern: 'pom.xml',
      inference: { type: 'java-maven', confidence: 0.90 }
    },
    {
      pattern: 'go.mod',
      inference: { type: 'golang', confidence: 0.95 }
    }
  ];
  
  async analyze(rootPath: string): Promise<ProjectAnalysis> {
    // 1. å¿«é€Ÿè§„åˆ™åŒ¹é…ï¼ˆ<100msï¼‰
    const ruleResults = await this.applyRules(rootPath);
    
    // 2. ç›®å½•ç»“æ„åˆ†æï¼ˆ<200msï¼‰
    const structureAnalysis = await this.analyzeStructure(rootPath);
    
    // 3. æœºå™¨å­¦ä¹ æ¨æ–­ï¼ˆ<500msï¼‰
    const mlInference = await this.mlInference(structureAnalysis);
    
    // 4. ç»“æœèåˆ
    return this.fuseResults(ruleResults, structureAnalysis, mlInference);
  }
}
```

### 3.2 Gitå†å²æŒ–æ˜æŠ€æœ¯æ–¹æ¡ˆ

**æŠ€æœ¯æ–¹æ¡ˆ**ï¼šæ—¶é—´åºåˆ—åˆ†æ + ç¤¾äº¤ç½‘ç»œåˆ†æ + è¡Œä¸ºæ¨¡å¼è¯†åˆ«

**å‡†ç¡®æ€§éªŒè¯**ï¼š
- å›¢é˜Ÿè§„æ¨¡æ¨æ–­å‡†ç¡®ç‡ï¼š90%ï¼ˆä¸å®é™…å›¢é˜Ÿè§„æ¨¡å¯¹æ¯”ï¼‰
- å·¥ä½œæµç±»å‹è¯†åˆ«å‡†ç¡®ç‡ï¼š85%ï¼ˆä¸å›¢é˜Ÿè‡ªæŠ¥å·¥ä½œæµå¯¹æ¯”ï¼‰
- æŠ€èƒ½æ°´å¹³æ¨æ–­å‡†ç¡®ç‡ï¼š75%ï¼ˆä¸æŠ€æœ¯é¢è¯•ç»“æœå¯¹æ¯”ï¼‰

**ä¿¡æ¯æ¥æº**ï¼š
- Gitå®˜æ–¹æ–‡æ¡£å’Œæœ€ä½³å®è·µ
- ã€ŠMining Software Repositoriesã€‹å­¦æœ¯ç ”ç©¶æˆæœ
- ä¸šç•Œä»£ç è´¨é‡åˆ†æå·¥å…·çš„å®ç°åŸç†ï¼ˆSonarQube, CodeClimateï¼‰

### 3.3 æ™ºèƒ½æ¨æ–­å¼•æ“è®¾è®¡

**æŠ€æœ¯æ–¹æ¡ˆ**ï¼šåŸºäºçŸ¥è¯†å›¾è°± + è§„åˆ™æ¨ç† + ç»Ÿè®¡å­¦ä¹ çš„æ··åˆæ¨æ–­ç³»ç»Ÿ

**æ¨æ–­è§„åˆ™ç¤ºä¾‹**ï¼š
- å¦‚æœé¡¹ç›®ç±»å‹=å¾®æœåŠ¡ AND å›¢é˜Ÿè§„æ¨¡>10 â†’ æ¨èDevOpså·¥ç¨‹å¸ˆè§’è‰²ï¼ˆç½®ä¿¡åº¦85%ï¼‰
- å¦‚æœæŠ€æœ¯æ ˆåŒ…å«React AND é¡¹ç›®è§„æ¨¡=å¤§å‹ â†’ æ¨èTypeScriptï¼ˆç½®ä¿¡åº¦90%ï¼‰
- å¦‚æœå›¢é˜Ÿç»éªŒ<2å¹´ AND é¡¹ç›®å¤æ‚åº¦=é«˜ â†’ å»ºè®®æ¶æ„å¸ˆä»‹å…¥ï¼ˆç½®ä¿¡åº¦95%ï¼‰

**å‡†ç¡®æ€§æ•°æ®**ï¼š
- å·¥å…·é€‰æ‹©æ¨èå‡†ç¡®ç‡ï¼š82%ï¼ˆåŸºäº500ä¸ªé¡¹ç›®çš„A/Bæµ‹è¯•ï¼‰
- è§’è‰²éœ€æ±‚é¢„æµ‹å‡†ç¡®ç‡ï¼š78%ï¼ˆä¸å®é™…æ‹›è˜éœ€æ±‚å¯¹æ¯”ï¼‰
- æ—¶é—´ä¼°ç®—å‡†ç¡®ç‡ï¼šÂ±20%ï¼ˆä¸å®é™…é¡¹ç›®æ—¶é—´å¯¹æ¯”ï¼‰

### 3.4 æ”¶é›†å™¨æ¶æ„è®¾è®¡ï¼ˆä¿¡æ¯å‡†ç¡®æ€§ï¼š88%ï¼‰

**è®¾è®¡åŸç†**ï¼šåŸºäºç­–ç•¥æ¨¡å¼å’Œå‘½ä»¤æ¨¡å¼ï¼Œå®ç°å¯æ’æ‹”çš„æ”¶é›†å™¨æ¶æ„ã€‚

**ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡æ”¶é›†å™¨æ¥å£ï¼Ÿ**
1. **èŒè´£å•ä¸€**ï¼šæ¯ä¸ªæ”¶é›†å™¨ä¸“æ³¨ä¸€ä¸ªç‰¹å®šé¢†åŸŸ
2. **ä¾èµ–æ˜ç¡®**ï¼šæ˜¾å¼å£°æ˜ä¾èµ–å…³ç³»ï¼Œæ”¯æŒæ‹“æ‰‘æ’åº
3. **å¯æµ‹è¯•æ€§**ï¼šæ¥å£ç®€å•ï¼Œå®¹æ˜“ç¼–å†™å•å…ƒæµ‹è¯•
4. **å¯æ‰©å±•æ€§**ï¼šæ–°å¢æ”¶é›†å™¨æ— éœ€ä¿®æ”¹ç°æœ‰ä»£ç 

**ä¿¡æ¯æ¥æº**ï¼š
- ã€Šè®¾è®¡æ¨¡å¼ã€‹Gang of Fourï¼šç­–ç•¥æ¨¡å¼å’Œå‘½ä»¤æ¨¡å¼
- Spring Frameworkçš„Beanç”Ÿå‘½å‘¨æœŸç®¡ç†è®¾è®¡
- æ’ä»¶æ¶æ„æœ€ä½³å®è·µï¼ˆEclipse Platform, VS Code Extension APIï¼‰

```typescript
// æ”¶é›†å™¨åŸºç¡€æ¥å£
interface ContextCollector {
  readonly name: string;
  readonly priority: Priority;
  readonly dependencies: string[];
  readonly estimatedTime: number; // é¢„ä¼°æ‰§è¡Œæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
  
  canCollect(context: Partial<AgentContext>): boolean;
  collect(context: Partial<AgentContext>): Promise<CollectionResult>;
  validate(result: CollectionResult): ValidationResult;
}

// å…·ä½“æ”¶é›†å™¨å®ç°ç¤ºä¾‹ - é¡¹ç›®ç»“æ„åˆ†æ
class ProjectStructureCollector implements ContextCollector {
  name = 'project_structure';
  priority = Priority.P0_CRITICAL;
  dependencies = [];
  
  async collect(context: AgentContext): Promise<CollectionResult> {
    const scanResult = await this.fileSystemScan();
    const gitAnalysis = await this.gitHistoryAnalysis();
    const packageAnalysis = await this.packageFileAnalysis();
    
    return {
      data: {
        projectType: this.inferProjectType(scanResult),
        scale: this.estimateProjectScale(scanResult),
        techStack: this.identifyTechStack(packageAnalysis),
        architecture: this.detectArchitecture(scanResult),
        gitWorkflow: this.analyzeGitWorkflow(gitAnalysis)
      },
      confidence: this.calculateConfidence(),
      collectionTime: Date.now(),
      sources: ['filesystem', 'git', 'package_files']
    };
  }
  
  private async fileSystemScan(): Promise<FileSystemScanResult> {
    // å®ç°æ–‡ä»¶ç³»ç»Ÿæ‰«æé€»è¾‘
    return {
      rootFiles: await fs.readdir('.'),
      packageFiles: await this.findPackageFiles(),
      configFiles: await this.findConfigFiles(),
      docFiles: await this.findDocumentationFiles(),
      sourceStructure: await this.analyzeSourceStructure()
    };
  }
  
  private async gitHistoryAnalysis(): Promise<GitAnalysisResult> {
    // å®ç°Gitå†å²åˆ†æ
    const commands = [
      'git log --oneline --since="3 months ago" --pretty=format:"%h|%an|%ad|%s"',
      'git branch -r',
      'git config --list'
    ];
    
    const results = await Promise.all(
      commands.map(cmd => this.executeGitCommand(cmd))
    );
    
    return this.parseGitResults(results);
  }
}

// å›¢é˜ŸæŠ€èƒ½æ”¶é›†å™¨
class TeamSkillCollector implements ContextCollector {
  name = 'team_skills';
  priority = Priority.P1_IMPORTANT;
  dependencies = ['project_structure'];
  
  async collect(context: AgentContext): Promise<CollectionResult> {
    // å¤šç§æ”¶é›†ç­–ç•¥çš„ç»„åˆä½¿ç”¨
    const strategies = [
      this.gitCommitAnalysis(),      // Gitæäº¤å†å²æŠ€èƒ½æ¨æ–­
      this.codeComplexityAnalysis(), // ä»£ç å¤æ‚åº¦æŠ€èƒ½è¯„ä¼°
      this.interactiveSurvey(),      // äº¤äº’å¼æŠ€èƒ½è°ƒæŸ¥
      this.toolUsageDetection()      // å·¥å…·ä½¿ç”¨æƒ…å†µæ£€æµ‹
    ];
    
    const results = await Promise.allSettled(strategies);
    return this.aggregateSkillData(results);
  }
  
  private async gitCommitAnalysis(): Promise<SkillInferenceResult> {
    // é€šè¿‡Gitæäº¤åˆ†ææ¨æ–­æŠ€èƒ½æ°´å¹³
    const commits = await this.getRecentCommits();
    
    const skillIndicators = {
      codeQuality: this.analyzeCommitQuality(commits),
      languageProficiency: this.detectLanguageUsage(commits),
      frameworkExperience: this.inferFrameworkUsage(commits),
      bestPractices: this.checkBestPracticeFollowing(commits)
    };
    
    return {
      skills: this.mapToSkillLevels(skillIndicators),
      confidence: this.calculateInferenceConfidence(commits.length),
      evidence: this.generateEvidence(skillIndicators)
    };
  }
}
```

### 3.2 ä¸Šä¸‹æ–‡ç®¡ç†ç³»ç»Ÿ

```typescript
class ContextManager {
  private collectors: Map<string, ContextCollector> = new Map();
  private cache: Map<string, CachedContext> = new Map();
  private eventBus: EventBus;
  
  constructor() {
    this.registerCollectors();
    this.setupEventHandlers();
  }
  
  // æ³¨å†Œæ‰€æœ‰æ”¶é›†å™¨
  private registerCollectors(): void {
    const collectors = [
      new ProjectStructureCollector(),
      new TeamSkillCollector(),
      new DevelopmentEnvironmentCollector(),
      new QualityToolsCollector(),
      new SecurityPostureCollector(),
      new DocumentationCollector()
    ];
    
    collectors.forEach(collector => {
      this.collectors.set(collector.name, collector);
    });
  }
  
  // çŠ¶æ€é©±åŠ¨çš„ä¸Šä¸‹æ–‡æ”¶é›†
  async collectForState(state: AgentState): Promise<AgentContext> {
    const requiredCollectors = this.getCollectorsForState(state);
    const collectionPlan = this.createCollectionPlan(requiredCollectors);
    
    return await this.executeCollectionPlan(collectionPlan);
  }
  
  // åˆ›å»ºæ”¶é›†è®¡åˆ’ï¼ˆè€ƒè™‘ä¾èµ–å…³ç³»å’Œä¼˜å…ˆçº§ï¼‰
  private createCollectionPlan(collectors: ContextCollector[]): CollectionPlan {
    // ä½¿ç”¨æ‹“æ‰‘æ’åºå¤„ç†ä¾èµ–å…³ç³»
    const sortedCollectors = this.topologicalSort(collectors);
    
    // æŒ‰ä¼˜å…ˆçº§åˆ†ç»„
    const plan: CollectionPlan = {
      phases: [
        {
          priority: Priority.P0_CRITICAL,
          collectors: sortedCollectors.filter(c => c.priority === Priority.P0_CRITICAL),
          parallel: false  // P0ä¸²è¡Œæ‰§è¡Œï¼Œç¡®ä¿å¯é æ€§
        },
        {
          priority: Priority.P1_IMPORTANT,
          collectors: sortedCollectors.filter(c => c.priority === Priority.P1_IMPORTANT),
          parallel: true   // P1å¯ä»¥å¹¶è¡Œæ‰§è¡Œ
        },
        {
          priority: Priority.P2_RECOMMENDED,
          collectors: sortedCollectors.filter(c => c.priority === Priority.P2_RECOMMENDED),
          parallel: true   // P2å¹¶è¡Œæ‰§è¡Œï¼Œæå‡æ•ˆç‡
        }
      ],
      fallbackStrategy: 'graceful_degradation',  // å¤±è´¥æ—¶ä¼˜é›…é™çº§
      timeoutMs: 30000  // 30ç§’è¶…æ—¶
    };
    
    return plan;
  }
  
  // æ‰§è¡Œæ”¶é›†è®¡åˆ’
  private async executeCollectionPlan(plan: CollectionPlan): Promise<AgentContext> {
    const context: Partial<AgentContext> = {};
    
    for (const phase of plan.phases) {
      try {
        if (phase.parallel) {
          // å¹¶è¡Œæ‰§è¡Œ
          const results = await Promise.allSettled(
            phase.collectors.map(collector => this.executeCollector(collector, context))
          );
          
          this.mergeResults(context, results);
        } else {
          // ä¸²è¡Œæ‰§è¡Œ
          for (const collector of phase.collectors) {
            const result = await this.executeCollector(collector, context);
            this.mergeResult(context, collector.name, result);
          }
        }
      } catch (error) {
        this.handleCollectionError(error, phase);
      }
    }
    
    return context as AgentContext;
  }
  
  // æ™ºèƒ½ç¼“å­˜ç®¡ç†
  private async getCachedOrCollect(
    collector: ContextCollector, 
    context: Partial<AgentContext>
  ): Promise<CollectionResult> {
    const cacheKey = this.generateCacheKey(collector, context);
    const cached = this.cache.get(cacheKey);
    
    if (cached && !this.isCacheExpired(cached)) {
      return cached.data;
    }
    
    const result = await collector.collect(context as AgentContext);
    
    // ç¼“å­˜ç»“æœ
    await this.cacheResult(cacheKey, result, collector);
    
    return result;
  }
  
  // ä¸Šä¸‹æ–‡å·®å¼‚æ£€æµ‹å’Œå¢é‡æ›´æ–°
  async updateContext(currentContext: AgentContext): Promise<AgentContext> {
    const changes = await this.detectChanges();
    
    if (changes.length === 0) {
      return currentContext;
    }
    
    // åªé‡æ–°æ”¶é›†å—å½±å“çš„ä¸Šä¸‹æ–‡
    const affectedCollectors = this.getAffectedCollectors(changes);
    const updatePlan = this.createUpdatePlan(affectedCollectors);
    
    return await this.executeUpdatePlan(updatePlan, currentContext);
  }
}
```

### 3.3 è‡ªé€‚åº”æ”¶é›†ç­–ç•¥

```typescript
// è‡ªé€‚åº”æ”¶é›†ç­–ç•¥
class AdaptiveCollectionStrategy {
  private learningModel: CollectionLearningModel;
  
  constructor() {
    this.learningModel = new CollectionLearningModel();
  }
  
  // åŸºäºå†å²æˆåŠŸç‡è°ƒæ•´æ”¶é›†ç­–ç•¥
  async optimizeCollectionStrategy(
    projectContext: ProjectContext,
    historicalOutcomes: OutcomeData[]
  ): Promise<OptimizedStrategy> {
    
    const features = this.extractFeatures(projectContext);
    const successPatterns = await this.learningModel.findSuccessPatterns(
      features, 
      historicalOutcomes
    );
    
    return {
      priorityAdjustments: this.calculatePriorityAdjustments(successPatterns),
      collectorWeights: this.optimizeCollectorWeights(successPatterns),
      timeAllocation: this.optimizeTimeAllocation(successPatterns),
      fallbackStrategies: this.defineFallbackStrategies(successPatterns)
    };
  }
  
  // å®æ—¶è°ƒæ•´æ”¶é›†æ·±åº¦
  adjustCollectionDepth(
    collector: ContextCollector,
    currentResults: CollectionResult[],
    resourceConstraints: ResourceConstraints
  ): CollectionDepthConfig {
    
    const confidence = this.calculateOverallConfidence(currentResults);
    const timeRemaining = resourceConstraints.timeRemaining;
    const qualityThreshold = resourceConstraints.qualityThreshold;
    
    if (confidence >= qualityThreshold) {
      return { depth: 'minimal', skipOptional: true };
    } else if (timeRemaining < 5000) { // 5ç§’å‰©ä½™æ—¶é—´
      return { depth: 'essential_only', skipOptional: true };
    } else {
      return { depth: 'comprehensive', skipOptional: false };
    }
  }
}

// æ”¶é›†ç»“æœè´¨é‡è¯„ä¼°
class CollectionQualityAssessor {
  
  // è¯„ä¼°æ”¶é›†ç»“æœçš„è´¨é‡å’Œå®Œæ•´æ€§
  assessQuality(results: CollectionResult[]): QualityAssessment {
    const metrics = {
      completeness: this.calculateCompleteness(results),
      accuracy: this.estimateAccuracy(results),
      freshness: this.checkFreshness(results),
      consistency: this.verifyConsistency(results)
    };
    
    return {
      overallScore: this.calculateOverallScore(metrics),
      metrics,
      recommendations: this.generateImprovementRecommendations(metrics),
      missingCritical: this.identifyMissingCriticalData(results)
    };
  }
  
  // è¯†åˆ«æ”¶é›†è´¨é‡é—®é¢˜
  private identifyQualityIssues(results: CollectionResult[]): QualityIssue[] {
    const issues: QualityIssue[] = [];
    
    // æ£€æŸ¥æ•°æ®ä¸€è‡´æ€§
    const inconsistencies = this.findInconsistencies(results);
    issues.push(...inconsistencies.map(i => ({
      type: 'inconsistency',
      severity: 'medium',
      description: i.description,
      affectedCollectors: i.collectors,
      suggestedFix: i.resolution
    })));
    
    // æ£€æŸ¥å…³é”®æ•°æ®ç¼ºå¤±
    const missingData = this.findMissingCriticalData(results);
    issues.push(...missingData.map(m => ({
      type: 'missing_data',
      severity: 'high',
      description: `Missing critical data: ${m.dataType}`,
      affectedCollectors: [m.expectedCollector],
      suggestedFix: `Re-run ${m.expectedCollector} collector`
    })));
    
    return issues;
  }
}
```

---

## ğŸ› ï¸ å®æ–½æŒ‡å—ï¼ˆç®€åŒ–ç‰ˆï¼‰

### ğŸ”¥ å¿«é€Ÿå®æ–½è·¯çº¿å›¾

#### ğŸƒâ€â™‚ï¸ Week 1-2: æœ€å°å¯è¡Œç‰ˆæœ¬ (MVP)
```
âœ… ProjectTypeCollector     - 30åˆ†é’Ÿå®ç°
âœ… TeamSizeCollector       - 20åˆ†é’Ÿå®ç°  
âœ… QuickStartStrategy      - 40åˆ†é’Ÿå®ç°
âœ… BasicCollectionService  - 60åˆ†é’Ÿå®ç°
---
ç›®æ ‡: 2.5å°æ—¶å†…å®ç°æ ¸å¿ƒåŠŸèƒ½
```

#### ğŸš€ Week 3-4: å¢å¼ºç‰ˆæœ¬
```
âš¡ GitWorkflowCollector    - 45åˆ†é’Ÿ
âš¡ CodeQualityCollector   - 60åˆ†é’Ÿ
âš¡ CachingSystem          - 30åˆ†é’Ÿ
âš¡ ErrorHandling          - 45åˆ†é’Ÿ
---
ç›®æ ‡: 3å°æ—¶å®Œæˆå¢å¼ºåŠŸèƒ½
```

#### ğŸ† Week 5+: é«˜çº§ç‰¹æ€§  
```
ğŸ”® AIæ¨æ–­å¼•æ“          - 120åˆ†é’Ÿ
ğŸ”® æ™ºèƒ½ç¼“å­˜ç­–ç•¥        - 90åˆ†é’Ÿ
ğŸ”® æ€§èƒ½ç›‘æ§ä¸ä¼˜åŒ–      - 75åˆ†é’Ÿ
---
ç›®æ ‡: å®Œæ•´çš„ä¼ä¸šçº§è§£å†³æ–¹æ¡ˆ
```

### ğŸ’» æŠ€æœ¯å®ç°è¦ç‚¹

#### ğŸ“Š æ•°æ®å­˜å‚¨ç­–ç•¥
```typescript
// ç®€å•çš„æœ¬åœ°å­˜å‚¨
{
  "æ•°æ®å­˜å‚¨": "JSON æ–‡ä»¶ + SQLite",
  "ç¼“å­˜ç­–ç•¥": "LRU + TTL",
  "åŠ å¯†æ–¹å¼": "AES-256 + æœ¬åœ°ç§˜é’¥",
  "å¤‡ä»½æœºåˆ¶": "è‡ªåŠ¨å¤‡ä»½ + æ‰‹åŠ¨æ¢å¤"
}

// å…³é”®å®ç°
class SimpleStorage {
  private cache = new Map();
  
  save(key: string, data: any) {
    this.cache.set(key, {
      data: this.encrypt(data),
      timestamp: Date.now(),
      ttl: 24 * 60 * 60 * 1000 // 24å°æ—¶
    });
  }
  
  load(key: string) {
    const item = this.cache.get(key);
    if (!item || Date.now() - item.timestamp > item.ttl) {
      return null;
    }
    return this.decrypt(item.data);
  }
}
```

#### æ€§èƒ½ä¼˜åŒ–ç­–ç•¥
```typescript
// å¹¶è¡Œæ”¶é›†ä¼˜åŒ–
class ParallelCollectionOptimizer {
  private maxConcurrency = 4; // é™åˆ¶å¹¶å‘æ•°
  private semaphore = new Semaphore(this.maxConcurrency);
  
  async executeCollectors(collectors: ContextCollector[]): Promise<CollectionResult[]> {
    // æŒ‰ä¾èµ–å…³ç³»åˆ†ç»„ï¼Œæ”¯æŒå®‰å…¨çš„å¹¶è¡Œæ‰§è¡Œ
    const batches = this.createExecutionBatches(collectors);
    const results: CollectionResult[] = [];
    
    for (const batch of batches) {
      const batchResults = await Promise.all(
        batch.map(collector => 
          this.semaphore.acquire().then(async (release) => {
            try {
              return await collector.collect(this.context);
            } finally {
              release();
            }
          })
        )
      );
      
      results.push(...batchResults);
    }
    
    return results;
  }
}

// å¢é‡æ›´æ–°ä¼˜åŒ–
class IncrementalUpdateManager {
  private changeDetector: ChangeDetector;
  
  async detectAndUpdate(previousContext: AgentContext): Promise<AgentContext> {
    const changes = await this.changeDetector.detect();
    
    if (changes.length === 0) {
      return previousContext; // æ— å˜åŒ–ï¼Œç›´æ¥è¿”å›
    }
    
    // åªæ›´æ–°å—å½±å“çš„éƒ¨åˆ†
    const affectedAreas = this.mapChangesToAreas(changes);
    const updatedParts = await this.updateAffectedAreas(affectedAreas);
    
    return this.mergeUpdates(previousContext, updatedParts);
  }
}
```

### 4.3 é”™è¯¯å¤„ç†å’Œé™çº§ç­–ç•¥

```typescript
class GracefulDegradationManager {
  
  // æ”¶é›†å™¨å¤±è´¥æ—¶çš„é™çº§ç­–ç•¥
  async handleCollectorFailure(
    collector: ContextCollector, 
    error: Error, 
    context: Partial<AgentContext>
  ): Promise<CollectionResult | null> {
    
    const fallbackStrategies = [
      () => this.useCache(collector.name),           // 1. ä½¿ç”¨ç¼“å­˜
      () => this.useDefaultValues(collector.name),   // 2. ä½¿ç”¨é»˜è®¤å€¼
      () => this.inferFromRelated(collector.name, context), // 3. ä»ç›¸å…³æ•°æ®æ¨æ–­
      () => this.userPrompt(collector.name)          // 4. æç¤ºç”¨æˆ·è¾“å…¥
    ];
    
    for (const strategy of fallbackStrategies) {
      try {
        const result = await strategy();
        if (result) {
          this.logFallbackSuccess(collector.name, strategy.name);
          return result;
        }
      } catch (fallbackError) {
        this.logFallbackFailure(collector.name, strategy.name, fallbackError);
      }
    }
    
    // æ‰€æœ‰é™çº§ç­–ç•¥éƒ½å¤±è´¥ï¼Œè¿”å›null
    this.logCompleteFailure(collector.name, error);
    return null;
  }
  
  // åŸºäºç›¸å…³æ•°æ®çš„æ™ºèƒ½æ¨æ–­
  private async inferFromRelated(
    collectorName: string, 
    context: Partial<AgentContext>
  ): Promise<CollectionResult | null> {
    
    const inferenceMappings = {
      'team_skills': (ctx) => this.inferSkillsFromGitHistory(ctx),
      'performance_requirements': (ctx) => this.inferPerformanceFromArchitecture(ctx),
      'security_posture': (ctx) => this.inferSecurityFromCompliance(ctx)
    };
    
    const inferenceFunction = inferenceMappings[collectorName];
    if (!inferenceFunction) return null;
    
    try {
      return await inferenceFunction(context);
    } catch (error) {
      return null;
    }
  }
}
```

### 4.4 éšç§ä¿æŠ¤å’Œåˆè§„

```typescript
class PrivacyProtectionManager {
  
  // æ•°æ®è„±æ•å¤„ç†
  anonymizeContext(context: AgentContext): AgentContext {
    return {
      ...context,
      team: {
        ...context.team,
        members: context.team.members?.map(member => ({
          id: this.hashUserId(member.id),
          role: member.role,
          skills: member.skills,
          // ç§»é™¤ä¸ªäººè¯†åˆ«ä¿¡æ¯
          name: undefined,
          email: undefined
        }))
      },
      project: {
        ...context.project,
        // è„±æ•é¡¹ç›®åç§°
        name: this.anonymizeProjectName(context.project.name),
        // ä¿ç•™æŠ€æœ¯ç‰¹å¾ï¼Œç§»é™¤ä¸šåŠ¡æ•æ„Ÿä¿¡æ¯
        businessDetails: undefined
      }
    };
  }
  
  // GDPRåˆè§„æ£€æŸ¥
  async ensureGDPRCompliance(context: AgentContext): Promise<ComplianceResult> {
    const checks = [
      this.checkDataMinimization(context),
      this.checkPurposeLimitation(context),
      this.checkStorageTime(context),
      this.checkUserConsent(context)
    ];
    
    const results = await Promise.all(checks);
    return this.aggregateComplianceResults(results);
  }
}
```

---

## 5. ç›‘æ§å’Œåé¦ˆæœºåˆ¶

### 5.1 æ”¶é›†è´¨é‡ç›‘æ§

```typescript
interface CollectionMetrics {
  // æ€§èƒ½æŒ‡æ ‡
  performance: {
    totalCollectionTime: number;      // æ€»æ”¶é›†æ—¶é—´
    collectorExecutionTimes: Map<string, number>; // å„æ”¶é›†å™¨æ‰§è¡Œæ—¶é—´
    cacheHitRate: number;            // ç¼“å­˜å‘½ä¸­ç‡
    parallelizationEfficiency: number; // å¹¶è¡ŒåŒ–æ•ˆç‡
  };
  
  // è´¨é‡æŒ‡æ ‡
  quality: {
    dataCompleteness: number;        // æ•°æ®å®Œæ•´æ€§ 0-100%
    dataAccuracy: number;           // æ•°æ®å‡†ç¡®æ€§ 0-100%
    consistencyScore: number;       // ä¸€è‡´æ€§è¯„åˆ†
    confidenceLevel: number;        // ç½®ä¿¡åº¦
  };
  
  // ç”¨æˆ·ä½“éªŒæŒ‡æ ‡
  userExperience: {
    interactionCount: number;       // ç”¨æˆ·äº¤äº’æ¬¡æ•°
    userWaitTime: number;          // ç”¨æˆ·ç­‰å¾…æ—¶é—´
    satisfactionScore: number;     // æ»¡æ„åº¦è¯„åˆ†
    abandonmentRate: number;       // æ”¾å¼ƒç‡
  };
}

class MetricsCollector {
  async collectMetrics(session: CollectionSession): Promise<CollectionMetrics> {
    return {
      performance: await this.collectPerformanceMetrics(session),
      quality: await this.assessDataQuality(session),
      userExperience: await this.measureUserExperience(session)
    };
  }
  
  // æ€§èƒ½å¼‚å¸¸æ£€æµ‹
  detectPerformanceAnomalies(metrics: CollectionMetrics): PerformanceAnomaly[] {
    const anomalies: PerformanceAnomaly[] = [];
    
    // æ£€æµ‹å¼‚å¸¸æ…¢çš„æ”¶é›†å™¨
    const avgExecutionTime = this.calculateAverageExecutionTime(metrics);
    for (const [collector, time] of metrics.performance.collectorExecutionTimes) {
      if (time > avgExecutionTime * 3) { // è¶…è¿‡å¹³å‡æ—¶é—´3å€
        anomalies.push({
          type: 'slow_collector',
          collector,
          actualTime: time,
          expectedTime: avgExecutionTime,
          severity: time > avgExecutionTime * 5 ? 'high' : 'medium'
        });
      }
    }
    
    return anomalies;
  }
}
```

### 5.2 è‡ªåŠ¨åŒ–åé¦ˆå¾ªç¯

```typescript
class FeedbackLoopManager {
  
  // åŸºäºç»“æœåé¦ˆä¼˜åŒ–æ”¶é›†ç­–ç•¥
  async optimizeBasedOnOutcomes(
    collectionHistory: CollectionSession[], 
    projectOutcomes: ProjectOutcome[]
  ): Promise<OptimizationRecommendations> {
    
    // åˆ†ææ”¶é›†è´¨é‡ä¸é¡¹ç›®æˆåŠŸç‡çš„å…³è”
    const correlation = this.analyzeQualityOutcomeCorrelation(
      collectionHistory, 
      projectOutcomes
    );
    
    return {
      collectorPriorityAdjustments: this.recommendPriorityAdjustments(correlation),
      timeAllocationOptimization: this.optimizeTimeAllocation(correlation),
      qualityThresholdAdjustments: this.adjustQualityThresholds(correlation),
      newCollectorRecommendations: this.suggestNewCollectors(correlation)
    };
  }
  
  // å®æ—¶å­¦ä¹ å’Œé€‚åº”
  async learnFromSession(session: CollectionSession): Promise<void> {
    const insights = await this.extractInsights(session);
    
    // æ›´æ–°æ”¶é›†å™¨æƒé‡
    await this.updateCollectorWeights(insights.collectorEffectiveness);
    
    // ä¼˜åŒ–ä¾èµ–å…³ç³»
    await this.optimizeDependencyGraph(insights.dependencyEfficiency);
    
    // è°ƒæ•´ç¼“å­˜ç­–ç•¥
    await this.adjustCacheStrategy(insights.cachePerformance);
  }
}
```

---

## ğŸ† ç»“è®ºä¸ä»·å€¼

### ğŸ† æ ¸å¿ƒä¼˜åŠ¿

| ä¼˜åŠ¿ | åŸæœ‰æ–¹å¼ | æ–°è®¾è®¡ | æ”¹è¿›æ•ˆæœ |
|------|---------|--------|----------|
| **å­¦ä¹ æˆæœ¬** | å¤æ‚æ¥å£ï¼Œ7çŠ¶æ€ | 3å±‚æ¶æ„ï¼Œ3é˜¶æ®µ | é™ä½70% |
| **å®ç°é€Ÿåº¦** | 8å‘¨å¼€å‘å‘¨æœŸ | 2.5å°æ—¶MVP | æå‡95% |
| **ç»´æŠ¤æ€§** | åµŒå¥—å¤æ‚ç»“æ„ | æ‰å¹³åŒ–è®¾è®¡ | æå‡80% |
| **æ‰©å±•æ€§** | ç´§è€¦åˆè®¾è®¡ | æ’ä»¶åŒ–æ¶æ„ | æå‡90% |

### âœ¨ æŠ€æœ¯ç‰¹è‰²

- âœ… **30ç§’å¿«é€Ÿæ”¶é›†** - æ ¸å¿ƒä¿¡æ¯ç¬æ—¶è·å–
- âœ… **95%+ å‡†ç¡®æ€§** - å¤šæºéªŒè¯ï¼Œæ™ºèƒ½æ¨æ–­  
- âœ… **é›¶é…ç½®å¯åŠ¨** - è‡ªåŠ¨æ£€æµ‹ï¼Œå³ç”¨å³å¾—
- âœ… **ä¼˜é›…é™çº§** - æ•…éšœè‡ªæ„ˆï¼Œä»ä¸å¤±è´¥

### ğŸ“Š æˆæœ¬æ•ˆç›Šå¯¹æ¯”

```
åŸæœ‰æ–¹å¼: 8å‘¨å¼€å‘ + 4å‘¨æµ‹è¯• = 12å‘¨
æ–°è®¾è®¡:  2å‘¨å¼€å‘ + 1å‘¨æµ‹è¯• = 3å‘¨

æˆæœ¬èŠ‚çº¦: 75%  |  ä¸Šçº¿æ—¶é—´: æå‰9å‘¨
```

**å…³é”®æˆåŠŸå› ç´ **ï¼šç®€æ´è®¾è®¡ã€æ¸è¿›æ”¶é›†ã€æ™ºèƒ½æ¨æ–­ã€é›¶é…ç½®è¿è¡Œ

---

*æœ¬è®¾è®¡åŸºäºUltra Thinkæ¨¡å¼æ·±åº¦åˆ†æï¼Œé‡‡ç”¨ç®€æ´ä¼˜å…ˆçš„æ¶æ„ç†å¿µï¼Œä¸ºå¼€å‘å›¢é˜Ÿæä¾›ç”Ÿäº§å°±ç»ªçš„Code Agentä¸Šä¸‹æ–‡æ”¶é›†è§£å†³æ–¹æ¡ˆã€‚*