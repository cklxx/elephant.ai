package main

import (
	"context"
	"errors"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"time"
)

type demoOptions struct {
	scriptPath        string
	outputPath        string
	resolution        string
	segmentDuration   float64
	sourceManifest    string
	primaryAudio      string
	secondaryAudio    string
	fontFile          string
	audioVolume       float64
	simulateMissing   bool
	ffmpegBin         string
	ffprobeBin        string
	enableGPU         bool
	gpuBackend        string
	videoCodec        string
	videoPreset       string
	runStatusFile     string
	metricsLog        string
	watermarkText     string
	watermarkFont     int
	watermarkOpacity  float64
	watermarkMargin   int
	watermarkPosition string
	watermarkImage    string
	watermarkScale    float64
	watermarkImgAlpha float64
	subtitleFile      string
	subtitleCharset   string
	subtitleStyle     string
}

func main() {
	var opts demoOptions
	flag.StringVar(&opts.scriptPath, "script", "scripts/video_editing_demo.sh", "Path to the video editing demo script")
	flag.StringVar(&opts.outputPath, "output", "video_editing_demo.mp4", "Destination path for the rendered clip")
	flag.StringVar(&opts.resolution, "resolution", "1280x720", "Resolution used when generating placeholder segments")
	flag.Float64Var(&opts.segmentDuration, "segment-duration", 2.0, "Duration in seconds for generated segments")
	flag.StringVar(&opts.sourceManifest, "manifest", "", "Optional FFmpeg concat manifest to stitch instead of autogenerated segments")
	flag.StringVar(&opts.primaryAudio, "primary-audio", "", "Optional primary audio track path")
	flag.StringVar(&opts.secondaryAudio, "secondary-audio", "", "Optional secondary audio track path")
	flag.StringVar(&opts.fontFile, "font-file", "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", "Font used by drawtext in the demo")
	flag.Float64Var(&opts.audioVolume, "audio-volume", 0.2, "Final audio volume multiplier applied by the demo script")
	flag.BoolVar(&opts.simulateMissing, "simulate-missing-input", false, "Simulate the missing-segment failure path before rendering the clip")
	flag.StringVar(&opts.ffmpegBin, "ffmpeg-bin", "ffmpeg", "FFmpeg binary to use when running the demo script")
	flag.StringVar(&opts.ffprobeBin, "ffprobe-bin", "ffprobe", "FFprobe binary to use when running the demo script")
	flag.BoolVar(&opts.enableGPU, "enable-gpu", false, "Attempt to enable GPU mode inside the demo script")
	flag.StringVar(&opts.gpuBackend, "gpu-backend", "auto", "Preferred GPU backend (auto|cuda|vaapi)")
	flag.StringVar(&opts.videoCodec, "video-codec", "", "Override the video codec used by the demo script")
	flag.StringVar(&opts.videoPreset, "video-preset", "", "Override the video preset used by the demo script")
	flag.StringVar(&opts.runStatusFile, "run-status-file", "", "Optional path for the demo script to log timing/output metadata")
	flag.StringVar(&opts.metricsLog, "metrics-log", "", "Optional pseudo-metrics log file appended by the demo script")
	flag.StringVar(&opts.watermarkText, "watermark-text", "DEMO_WATERMARK", "Text rendered by the drawtext watermark")
	flag.IntVar(&opts.watermarkFont, "watermark-font-size", 48, "Font size used for the watermark text")
	flag.Float64Var(&opts.watermarkOpacity, "watermark-opacity", 0.7, "Opacity (0-1) for the watermark text")
	flag.IntVar(&opts.watermarkMargin, "watermark-margin", 40, "Pixel margin between the watermark and its anchor edge")
	flag.StringVar(&opts.watermarkPosition, "watermark-position", "bottom-right", "Watermark anchor (bottom-right,bottom-left,top-right,top-left,center)")
	flag.StringVar(&opts.watermarkImage, "watermark-image", "", "Optional PNG watermark path blended on top of the video")
	flag.Float64Var(&opts.watermarkScale, "watermark-image-scale", 1.0, "Scale multiplier applied to the PNG watermark (1 keeps original size)")
	flag.Float64Var(&opts.watermarkImgAlpha, "watermark-image-opacity", 1.0, "Opacity (0-1) multiplier for the PNG watermark")
	flag.StringVar(&opts.subtitleFile, "subtitle-file", "", "Optional subtitle file (SRT/ASS) rendered through the demo script")
	flag.StringVar(&opts.subtitleCharset, "subtitle-charset", "UTF-8", "Charset passed to the ffmpeg subtitles filter")
	flag.StringVar(&opts.subtitleStyle, "subtitle-style", "", "Optional force_style string applied when rendering subtitles (still missing preset library)")
	flag.Parse()

	if err := runDemo(opts); err != nil {
		fmt.Fprintf(os.Stderr, "videoedit: %v\n", err)
		os.Exit(1)
	}
}

func runDemo(opts demoOptions) error {
	script, err := resolveScript(opts.scriptPath)
	if err != nil {
		return err
	}

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Minute)
	defer cancel()

	cmd := exec.CommandContext(ctx, script)
	cmd.Env = buildDemoEnv(opts)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	return cmd.Run()
}

func buildDemoEnv(opts demoOptions) []string {
	env := os.Environ()
	appendEnv := func(key, value string) {
		env = append(env, fmt.Sprintf("%s=%s", key, value))
	}

	appendEnv("OUTPUT_PATH", opts.outputPath)
	appendEnv("VIDEO_RESOLUTION", opts.resolution)
	appendEnv("SEGMENT_DURATION", formatFloat(opts.segmentDuration))
	appendEnv("SOURCE_MANIFEST", opts.sourceManifest)
	appendEnv("PRIMARY_AUDIO_PATH", opts.primaryAudio)
	appendEnv("SECONDARY_AUDIO_PATH", opts.secondaryAudio)
	appendEnv("FONT_FILE", opts.fontFile)
	appendEnv("AUDIO_VOLUME", formatFloat(opts.audioVolume))
	if opts.simulateMissing {
		appendEnv("SIMULATE_MISSING_INPUT", "1")
	} else {
		appendEnv("SIMULATE_MISSING_INPUT", "0")
	}
	appendEnv("FFMPEG_BIN", opts.ffmpegBin)
	appendEnv("FFPROBE_BIN", opts.ffprobeBin)
	if opts.enableGPU {
		appendEnv("ENABLE_GPU", "1")
	} else {
		appendEnv("ENABLE_GPU", "0")
	}
	appendEnv("PREFERRED_GPU_BACKEND", opts.gpuBackend)
	appendEnv("VIDEO_CODEC", opts.videoCodec)
	appendEnv("VIDEO_PRESET", opts.videoPreset)
	appendEnv("RUN_STATUS_FILE", opts.runStatusFile)
	appendEnv("METRICS_LOG_PATH", opts.metricsLog)
	appendEnv("WATERMARK_TEXT", opts.watermarkText)
	appendEnv("WATERMARK_FONT_SIZE", formatInt(opts.watermarkFont))
	appendEnv("WATERMARK_OPACITY", formatFloat(opts.watermarkOpacity))
	appendEnv("WATERMARK_MARGIN", formatInt(opts.watermarkMargin))
	appendEnv("WATERMARK_POSITION", opts.watermarkPosition)
	appendEnv("WATERMARK_IMAGE_PATH", opts.watermarkImage)
	appendEnv("WATERMARK_IMAGE_SCALE", formatFloat(opts.watermarkScale))
	appendEnv("WATERMARK_IMAGE_OPACITY", formatFloat(opts.watermarkImgAlpha))
	appendEnv("SUBTITLE_FILE", opts.subtitleFile)
	appendEnv("SUBTITLE_CHARSET", opts.subtitleCharset)
	appendEnv("SUBTITLE_FORCE_STYLE", opts.subtitleStyle)

	return env
}

func formatFloat(v float64) string {
	return strings.TrimRight(strings.TrimRight(fmt.Sprintf("%.6f", v), "0"), ".")
}

func formatInt(v int) string {
	return strconv.Itoa(v)
}

func resolveScript(script string) (string, error) {
	if script == "" {
		return "", errors.New("script path must not be empty")
	}

	candidates := candidateScripts(script)
	for _, candidate := range candidates {
		abs, err := filepath.Abs(candidate)
		if err != nil {
			continue
		}
		if info, err := os.Stat(abs); err == nil && !info.IsDir() {
			return abs, nil
		}
	}

	return "", fmt.Errorf("unable to locate script %q; checked %v", script, candidates)
}

func candidateScripts(script string) []string {
	var candidates []string
	add := func(path string) {
		if path == "" {
			return
		}
		for _, existing := range candidates {
			if existing == path {
				return
			}
		}
		candidates = append(candidates, path)
	}

	add(script)
	if !filepath.IsAbs(script) {
		if wd, err := os.Getwd(); err == nil {
			add(filepath.Join(wd, script))
		}
		if exe, err := os.Executable(); err == nil {
			base := filepath.Dir(exe)
			add(filepath.Join(base, script))
			add(filepath.Join(base, "..", script))
			add(filepath.Join(base, "..", "..", script))
		}
	}
	return candidates
}
